本脚本代码用来演示如何计算三堆牌抽取游戏中的必胜策略

点击 [Online Demo](https://repl.it/@JingZhang1/3HeapCardsGame)

link: https://repl.it/@JingZhang1/3HeapCardsGame

或下载/3_heap.py到本地文件夹，在Python3环境中运行

显示的必胜点集合规模为 pow(2, RANK)

调整代码中的常数RANK，即可改变显示必胜点的集合规模


定义：

1. 必胜点: 上一步操作后，留给对手的牌型，对手无论如何操作必败

2. 可抽次数：一堆牌在抽完之前还可以抽多少次


分析：

1. 游戏存在最小必胜点：

  1.1 两组牌必胜点为[2, 2]，

  1.2 三组牌存在两种最小必胜点[0, 2, 2], [1, 1, 1]

这个游戏问题在于无法计算剩余总可抽次数，因为每一堆的可抽次数在牌数大于2的情况下都存在不确定性，

但是我们可以保证剩余可抽次数的穷举总量始终为偶数，这样可以通过和对手进行反向操作将对手逼向最小必胜点


问题转化:

1. 我们可以将牌数转化成二进制序列，对于每一个数位来说，可抽取次数就确定成0或1次的序列组合

  5 -> 1 0 1

  6 -> 1 1 0

  7 -> 1 1 1

2. 将每一个点上的1看作是一根火柴棍，抽牌的动作可以转化为添加或去掉火柴棍，规则如下

  2.1 每一个点位火柴棍的数量只能是 0 或 1

  2.2 每一步操作中，可以任意去掉某个或多个点位的火柴棍（数字可以任意减小）

  2.3 在每一步操作中，只有去掉过火柴棍点位的右侧才可以同步添加火柴棍（数字不会增大）

3. 被迫去掉最后一堆最后一根火柴棍的选手输


必胜策略: 迫使对手进入本方最小必胜点 

Case (1)

0 -> 0 0 0 

2 -> 0 1 0

2 -> 0 1 0

Case (2)

1 -> 0 0 1

1 -> 0 0 1

1 -> 0 0 1


策略分析: 倒推

Case (1)：

从最小必胜点出发，在对手的每一步之后，另选一堆做反向操作，保证反推过程的任何一个牌型都能和对手通过偶数步操作返回最小必胜点

0 0 0  -> (1) 0 0

0 1 0  -> (1) 1 0

0 1 0  -> 0 1 0

因为每一步操作都被相等复制，因此，从(0, 2, 2)反推，二进制每一列的总和进行模2运算结果为0，

即函数 f() =  sum %2 = 0

因此，从游戏开始正向运算的时候，我们只需要把三组数二进制化，计算每一列的f()

保证每一列都为0必胜，因为对手无论如何操作，我们只需要找一行做反向操作，就能永远保证 f() = 0

但是，以下情况例外：

Case(2)

当对手操作完之后出现(1, 1, n)牌型时，需要改变case(1)的策略，转而在n堆中抓取n-1，从而进入(1, 1, 1)的必胜点